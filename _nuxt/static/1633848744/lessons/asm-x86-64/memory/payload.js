__NUXT_JSONP__("/lessons/asm-x86-64/memory", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_){return {data:[{content:{slug:y,layout:"lesson",module:u,title:D,desc:"Download more RAM!",order:4,omulator:E,toc:[{id:F,depth:t,text:G},{id:H,depth:t,text:I},{id:J,depth:t,text:K},{id:L,depth:t,text:M},{id:i,depth:z,text:i},{id:m,depth:z,text:m}],body:{type:"root",children:[{type:b,tag:e,props:{},children:[{type:a,value:"Earlier we covered the concept of "},{type:b,tag:f,props:{},children:[{type:a,value:N}]},{type:a,value:", which act as small temporary variables to store data between computations.\nNow, we need to understand what "},{type:b,tag:f,props:{},children:[{type:a,value:y}]},{type:a,value:" is."}]},{type:a,value:c},{type:b,tag:v,props:{id:F},children:[{type:b,tag:n,props:{ariaHidden:k,href:"#what-is-memory",tabIndex:o},children:[{type:b,tag:p,props:{className:[q,r]},children:[]}]},{type:a,value:G}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"When we think of memory, we'd immediately think of human memory and our ability to store and recall facts, feelings and much more complex information.\nFor those with more background in computers, you may think of "},{type:b,tag:l,props:{},children:[{type:a,value:"hard-drive"}]},{type:a,value:" or "},{type:b,tag:l,props:{},children:[{type:a,value:"SSD"}]},{type:a,value:" space as memory of the computer.\nHowever, when we speak of "},{type:b,tag:f,props:{},children:[{type:a,value:y}]},{type:a,value:" in terms of the "},{type:b,tag:f,props:{},children:[{type:a,value:O}]},{type:a,value:" (like a x86), we generally are referring to "},{type:b,tag:f,props:{},children:[{type:a,value:"RAM"}]},{type:a,value:" (random-access memory)."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"RAM or memory refers to a short-term data storage area which our CPU can access and modify for it's needs while running programs.\nWhile registers are supposed to be used for intermediate data in calculations, registers are limited in number and in capacity.\nMemory on the other hand, is generally much more abundant and can store much larger quantities of intermediate data.\nHowever, memory will be slower to read\u002Fwrite from than registers.\nThus both have their pros and cons, and should be used appropriately depending on the context."}]},{type:a,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:b,tag:"table",props:{},children:[{type:b,tag:"thead",props:{},children:[{type:b,tag:w,props:{},children:[{type:b,tag:A,props:{align:g},children:[{type:a,value:"Comparison"}]},{type:b,tag:A,props:{align:g},children:[{type:a,value:"Memory\u002FRAM"}]},{type:b,tag:A,props:{align:g},children:[{type:a,value:"Registers"}]}]}]},{type:b,tag:"tbody",props:{},children:[{type:b,tag:w,props:{},children:[{type:b,tag:j,props:{align:g},children:[{type:a,value:"Faster access"}]},{type:b,tag:j,props:{align:g},children:[]},{type:b,tag:j,props:{align:g},children:[{type:a,value:x}]}]},{type:b,tag:w,props:{},children:[{type:b,tag:j,props:{align:g},children:[{type:a,value:"Greater capacity"}]},{type:b,tag:j,props:{align:g},children:[{type:a,value:x}]},{type:b,tag:j,props:{align:g},children:[]}]},{type:b,tag:w,props:{},children:[{type:b,tag:j,props:{align:g},children:[{type:a,value:"Volatile?"},{type:b,tag:"br",props:{},children:[]},{type:a,value:"(Lost with power removed)"}]},{type:b,tag:j,props:{align:g},children:[{type:a,value:x}]},{type:b,tag:j,props:{align:g},children:[{type:a,value:x}]}]}]}]},{type:a,value:c},{type:b,tag:v,props:{id:H},children:[{type:b,tag:n,props:{ariaHidden:k,href:"#an-analogy-for-memory",tabIndex:o},children:[{type:b,tag:p,props:{className:[q,r]},children:[]}]},{type:a,value:I}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"We can try to extend our analogy from earlier lessons.\nIf we recall that the "},{type:b,tag:f,props:{},children:[{type:a,value:O}]},{type:a,value:" is a dumb chef "},{type:b,tag:l,props:{},children:[{type:a,value:"Bob"}]},{type:a,value:", and Bob stores his ingredients in "},{type:b,tag:l,props:{},children:[{type:a,value:"bowls"}]},{type:a,value:" ("},{type:b,tag:f,props:{},children:[{type:a,value:N}]},{type:a,value:") while working, then what would memory be?\n"},{type:b,tag:f,props:{},children:[{type:a,value:D}]},{type:a,value:" in this analogy could be thought of as the counter-top, or the fridge.\nIt can definitely store much larger quantities of ingredients (data) than a bowl could, but would require a bit more effort to walk to (access)."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:P,props:{alt:Q,src:"\u002Flessons\u002Fasm-x86-64\u002Fmemory\u002FBowlTable.png"},children:[]}]},{type:a,value:c},{type:b,tag:v,props:{id:J},children:[{type:b,tag:n,props:{ariaHidden:k,href:"#using-memory",tabIndex:o},children:[{type:b,tag:p,props:{className:[q,r]},children:[]}]},{type:a,value:K}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"So how do we "},{type:b,tag:l,props:{},children:[{type:a,value:"access"}]},{type:a,value:" memory through x86-64 code?\nMemory addresses!"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"From the CPU's point of view, memory is treated like a large array of bytes (8-bit numbers).\nIn order to differentiate the different areas of memory, the CPU labels them with "},{type:b,tag:f,props:{},children:[{type:a,value:"virtual addresses"}]},{type:a,value:".\nVirtual addresses are simply indexes from the start of memory (memory address 0)."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"By labelling all bytes of memory with this simple addressing, we can access any byte of memory with no issues.\nIf you are comfortable with C programming, you may know about "},{type:b,tag:l,props:{},children:[{type:a,value:"pointers"}]},{type:a,value:".\nIn fact, pointers just store the memory addresses of the areas in memory the pointers are pointing to."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:P,props:{alt:Q,src:"\u002Flessons\u002Fasm-x86-64\u002Fmemory\u002FMemoryTable.png"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"As you can see, each labelled space on the table above is like an area in memory!\nEach space can store an item(data), like the apple.\nIf the data is too large for one space, it can be stored across multiple continuous spaces in memory."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Enough theory, let's try to concretise our understanding with a real example!\nRecall the "},{type:b,tag:d,props:{},children:[{type:a,value:R}]},{type:a,value:" instruction taught earlier, we can actually "},{type:b,tag:d,props:{},children:[{type:a,value:R}]},{type:a,value:" values to and from memory as well!"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"The follow code snippet will move a 8-byte value from our memory into a register.\nThen, this value will be moved into our "},{type:b,tag:d,props:{},children:[{type:a,value:"OUT"}]},{type:a,value:" memory region @ "},{type:b,tag:l,props:{},children:[{type:a,value:"address"}]},{type:a,value:" "},{type:b,tag:d,props:{},children:[{type:a,value:"0x2000"}]},{type:a,value:S}]},{type:a,value:c},{type:b,tag:B,props:{"initial-code":"\nmov rax, [0x1000]\nmov rbx, 0x2000\nmov [rbx], rax\n",input:"efbeadde",":show-extras":k},children:[{type:a,value:C}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"As you can see, we make use of the "},{type:b,tag:d,props:{},children:[{type:a,value:"[]"}]},{type:a,value:" square brackets to dereference memory at addresses.\nThis can be dereferenced as an offset from "},{type:b,tag:d,props:{},children:[{type:a,value:"0"}]},{type:a,value:" (used on line 1) or dereferenced from the value of a register (used on line 3)."}]},{type:a,value:c},{type:b,tag:"info-box",props:{},children:[{type:a,value:"\nThe absolute addressing we use in line 1 is not commonly used, but we used it for better demonstration purposes.\n"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Relative addressing is a more popular way that memory is accessed and can be done with syntax like so:"}]},{type:a,value:c},{type:b,tag:B,props:{"initial-code":"\nmov rax, [rip+val]\nmov rbx, rax\nnop\nlea rax, [rip+val]\nmov rcx, [rax]\nhlt\nval:\ndd 0xcafebabe\n"},children:[{type:a,value:C}]},{type:a,value:c},{type:b,tag:v,props:{id:L},children:[{type:b,tag:n,props:{ariaHidden:k,href:"#the-stack",tabIndex:o},children:[{type:b,tag:p,props:{className:[q,r]},children:[]}]},{type:a,value:M}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"You may have learnt about the stack data structure from your university\u002Falgorithm lessons.\nThe stack data structure has great applications in our assembly programs as well!"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"When computer programs are loaded, it is common for the operation system (OS) to setup some basic features for the programs that are being run.\nThe stack is one such feature, and is simply a mapping of contiguous memory.\nHowever, a special register "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" will be set to an address within this stack."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Why is "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" special you ask?\n"},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" is named the stack pointer register, and is meant to "},{type:b,tag:f,props:{},children:[{type:a,value:"point"}]},{type:a,value:" to the top of the stack.\nSpecial instructions like "},{type:b,tag:d,props:{},children:[{type:a,value:i}]},{type:a,value:T},{type:b,tag:d,props:{},children:[{type:a,value:m}]},{type:a,value:" will take note of where "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" is pointing and act accordingly."}]},{type:a,value:c},{type:b,tag:U,props:{id:i},children:[{type:b,tag:n,props:{ariaHidden:k,href:"#push",tabIndex:o},children:[{type:b,tag:p,props:{className:[q,r]},children:[]}]},{type:a,value:i}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:i}]},{type:a,value:" takes a single operand, which can be a register or memory operand.\nIt will take the value of the operand, and write it into the address pointed to by "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:", it will then "},{type:b,tag:f,props:{},children:[{type:a,value:"decrement"}]},{type:a,value:" the value of "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:S}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"This behaviour is exactly like "},{type:b,tag:l,props:{},children:[{type:a,value:i}]},{type:a,value:"ing an element into a stack data structure."}]},{type:a,value:c},{type:b,tag:U,props:{id:m},children:[{type:b,tag:n,props:{ariaHidden:k,href:"#pop",tabIndex:o},children:[{type:b,tag:p,props:{className:[q,r]},children:[]}]},{type:a,value:m}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:m}]},{type:a,value:" will take a single operand "},{type:b,tag:d,props:{},children:[{type:a,value:V}]},{type:a,value:".\nIt will retrieve the value pointed to by "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:", and store that value into the "},{type:b,tag:d,props:{},children:[{type:a,value:V}]},{type:a,value:" operand.\n"},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" will then be incremented in order to \"pop\" the value off the stack."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"This concept may be difficult the understand just from reading our explanation, so take some time to step through the instructions below.\nTake note of the value of "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:W},{type:b,tag:d,props:{},children:[{type:a,value:"rax"}]},{type:a,value:W},{type:b,tag:d,props:{},children:[{type:a,value:"rbx"}]},{type:a,value:" when each instruction runs.\nThe "},{type:b,tag:f,props:{},children:[{type:a,value:"STACK"}]},{type:a,value:" view should reflect the state of the stack for you to observe as well."}]},{type:a,value:c},{type:b,tag:B,props:{"initial-code":"\nmov rax, 0xdeadbeef\npush rax\npush rax\npop rbx\n",":show-extras":k},children:[{type:a,value:C}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Here are a few key observations:"}]},{type:a,value:c},{type:b,tag:X,props:{},children:[{type:a,value:c},{type:b,tag:s,props:{},children:[{type:a,value:"The stack grows towards lower addresses ("},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" decreases after "},{type:b,tag:d,props:{},children:[{type:a,value:i}]},{type:a,value:")"}]},{type:a,value:c},{type:b,tag:s,props:{},children:[{type:b,tag:d,props:{},children:[{type:a,value:i}]},{type:a,value:T},{type:b,tag:d,props:{},children:[{type:a,value:m}]},{type:a,value:" cause "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" to be decremented and incremented by "},{type:b,tag:f,props:{},children:[{type:a,value:"8"}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:Y,props:{},children:[{type:a,value:c},{type:b,tag:s,props:{},children:[{type:a,value:"This is because on our 64-bit CPU, our stack elements are treated as 64-bit elements (8 bytes)"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:X,props:{start:z},children:[{type:a,value:c},{type:b,tag:s,props:{},children:[{type:a,value:"After "},{type:b,tag:d,props:{},children:[{type:a,value:"sub rsp, 8"}]},{type:a,value:", we can see that our "},{type:b,tag:d,props:{},children:[{type:a,value:"0xdeadbeef"}]},{type:a,value:" value still stays on the stack, and was not removed."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:Y,props:{},children:[{type:a,value:c},{type:b,tag:s,props:{},children:[{type:a,value:"Our stack data structure \"removes\" items from the stack by simply incrementing the value of "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" (out of sight, out of mind)"}]},{type:a,value:c},{type:b,tag:s,props:{},children:[{type:a,value:"Future pushes will just overwrite this value if necessary, so there is no need to waste CPU time to clear these values"}]},{type:a,value:c}]}]},dir:Z,path:"\u002Flessons\u002Fasm-x86-64\u002Fmemory",extension:".md",createdAt:_,updatedAt:_},module:{slug:"asm-x86-64",title:u,desc:"Learn about the assembly language understood by our home computers",diff:"Easy",order:t,toc:[],dir:"\u002Flessons",path:Z},prev:{slug:"numbers",module:u,title:"Numbers",desc:"Representation of numbers in the CPU"},next:{slug:"operators",module:u,title:"Operators",desc:"Perform operations on data"},isLesson:E,title:"Memory | ASM (x86-64)",challenges:[]}],fetch:{},mutations:void 0}}("text","element","\n","code","p","strong","center","rsp","push","td","true","em","pop","a",-1,"span","icon","icon-link","li",2,"ASM (x86-64)","h2","tr","✔️","memory",3,"th","mini-omulator","\n\n\n","Memory",true,"what-is-memory","What is memory","an-analogy-for-memory","An analogy for memory","using-memory","Using memory","the-stack","The Stack","registers","CPU","img","","mov","."," and ","h3","dst",", ","ol","ul","\u002Flessons\u002Fasm-x86-64","2021-10-03T06:40:13.988Z")));